

To Run:
make
./KarateKid


Karate Kid is a side-scroller fight game. The game progresses as the Main Player Character (PC) aka the Karate Kid moves through the environment, defeating Non-Player Characters (NPC)/ Enemy Characters by combat. As the player progresses, one enemy at a time, the difficulty in defeating the enemy increases, and after few such enemies, at the end of the game the PC must confront the Main Boss enemy. To win the game, the player must successfully reach the end and defeat the main boss. The game must be completed within a specific time limit whilst keeping the PC’s health in check.

Game Mechanics:
The player character moves in the environment using the left and right arrow keys. To show a smooth walking movement, the steps are counted and reset to 0 every time the max is reached. The punch attack is performed using the SpaceBar-key and the kick attack using the LeftShift-key.
At the Start of the game, the player is guided through a back story, which the user player can cycle through using the Enter-key. The ESC-key can be pressed to pause and resume the game. The Pause Menu saves the state of the PC and the Game’s clock is kept constant while in this state. The player’s score and health information are visible at the top of the screen. The game is over when you either win it by defeating the Main Enemy Boss at the end, or when you lose while in combat with any of the Enemy Characters.

Implementation with more details on game mechanics:
Scrollable Background and Tile Map:
	The game is based on a side-scroller environment, with a camera port constantly keeping the Player Character in sight. The camera makes sure that the Player Character is at all times, in the center of the screen for the Scrolling background. This is achieved by implementing the camera as an individual rectangle that constantly captures the Player Character’s location based on which it updates itself, so as to center the character within the camera Rect. The Camera is defined within the GameObject class from where it obtains the Player Character’s position information.
	The Background is implemented as a TileMap. We used 6 types of tiles to show diversity. They include tiles for the sky (1), for plants (2), rocks (3), clouds (4), ground(5) and grass-texture (6). The TileMap is an individual class that manages everything from the initializing to the rendering of the tiles in the game environment.

Start, Pause and End Screens:
For the implementation of the start, pause, and end screen, we created a new “ScreenManager” class. Similar to other classes used in this program, the ScreenManager class manages the initialization, state, and rendering of the screen. The GameEngine has an instance of ScreenManager that is used throughout the game to render and change the state of the screen as a response to events happening in the game. We have five different states for the ScreenManager; no screen (state 0), start screen (state 1), game over screen (state 2), pause screen (state 3), and won screen (state 4). The game is initialized with the start screen state and set so that the only user input that is accepted is the space bar, then the event handler in the GameEngine changes the state of the ScreenManager instance to no screen. Likewise, when the pause screen is called, the state of the ScreenManager object is updated, the game-time is locked, i.e, it does not update, and only the escape key is accepted. 
	Since the sprite characters (Player Character and Enemy Character) we chose for the game were created in a pixelated art type of style, all the screens use the “Arcade Classic” TTF font for continuity and to match the game aesthetic. Because we are implementing TTF, the screens do not need to be designed in the form of images. They can be implemented using the SDL TTF library which makes it a great option for easily changing the screens in the code. 

Player Character:
	The main Game Object of this game is the Player Character (PC). The player moves through the game using the PC. Since this is a sidescroller implementation the player can move left and right in the environment using the left and right arrow keys. For attacking its enemy the player can punch using the space bar and kick using the left shift keys. The player’s performance and lifetime in the game can be measured using the health indicator. The player loses health points when the Enemy Character manages to successfully attack it. Similarly, the Enemy Character loses health point when the PC successfully throws an attack at it. The punch-action has to performed be performed at a closer range to inflict damage to the enemy, whereas the kicks can be thrown from a much farther range. Hence to balance the range and  effectiveness of the attack the kick deals less damage to the Enemy Character than the punch attack would. Also because the Player Character is much farther to the enemy whilst performing the kick action the enemy is less likely to block kicks when compared to punches when the Player character has to be closer to the enemy to have any damaging effect on its opponent.

Enemy AI:
	The Enemy class is a highly modified form of the GameObject class. On initialization, it takes in the x-location, the health, the ‘strength’ (aggressiveness), and its block chance as input variables. The strength and block chance are used to decide how often the enemy attempts to block an attack, and how often it attempts to punch the player. It uses a State Machine structure to operate in the world of the game. Initially, the enemy is calm. However, once the PC is within a certain distance, an ‘alert’ flag is set. Once this flag is set, the enemy approaches the PC and begins to attack once it is within hit range. If the enemy’s health falls below zero, it is dead – the only updates then are the rendering of the enemy’s corpse.
Sound:
	A SoundManager class is responsible for playing sounds. It is implemented using the SDL_Mixer library. It contains both music and ‘chunks’ – small sounds effects that are meant to be played once and not looped. The SoundManager has a fixed list of chunks and music files to be played. Given a certain flag, the SoundManager will play the sound corresponding to that flag. It is up to the caller to decide when a given sound should be played. Instances of the SoundManager class exist in both the enemies and in the GameEngine itself. The Enemies use the SoundManager class to call out various remarks when they become alert, die, etc. The sounds are also used to draw attention to attack sequences. The GameEngine class also uses this to play music for the intial introduction along with some bits in the game world, etc.

Dialogue
	The Dialogue in this implementation is mainly to for the user to segue into the game. The dialogues give a small backstory of why the Player Character is in the fight-situation. This little addition gave the game a more customized feel. The dialogue is modified from the ScreenManager class. It utilizes a sequence input, which determines at which point in the dialogue the player is. Each time a ‘return’ is pressed, the sequence value is incremented. Each sequence is processed in a switch statement, with matching text and images. Concurrently, the SoundManager class contains a function for the dialogue which takes in the same sequence integer. Much the same occurs in this SoundManager function, where the correct line of dialogue is played corresponding to the sequence integer given.


Performance Indicators
	Health - The health bar is made of a red rectangle that is 300 units long. As the game progresses, this red health rectangle is updated to be of the value 3*PlayerHealth units in length. To convey the current health of the player, which is relative to the player character’s max health, a black outline of 300 units is displayed. This black outline stays stable throughout the game. To better indicate its purpose above this rectangle, a black rect with a 'Health' ttf text over it is displayed. The reason for implementing it as a “black rectangle” is because it helps to make the 'Health' text visible against the background elements of the game.
	Score – Another way to map the Player Character’ progress is the Score element. This Score element is also implemented as part of the ScreenManager and uses TTF to print out the score report on the playable screen. The score here is implemented like a timer that counts the maximum amount of time the player takes to completer the game. The game starts off with a score of 500 and goes down based on how long the game is running, so if a user can get through the game quickly, they get a higher score. If in the middle of the game, the user pauses the game, the score pauses too. The score also stops decrementing when the game is over.
Character Sprite flicker – Additional to show the impact and success of an attack we added a short red flicker where the entire character changes to the color red. For both the player and the enemy characters, every time the attack lands successfully on the opponent, the opponent character’s sprite flickers red once along with the sound effect to depict “being hurt by the hit”. 
